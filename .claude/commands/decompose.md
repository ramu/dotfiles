---
allowed-tools: Read, Glob, Grep, Write(~/tmp/claude-dev/**), Bash(gh issue view *), Bash(git rev-parse *), Bash(mkdir *)
description: 要件をタスクリストに分解する
---

# 要件分解コマンド

要件（自然言語テキスト、ファイルパス、GitHub Issue）を分析し、ralph-loop が消費できるタスクリストファイルを生成します。

## 引数の解析

`$ARGUMENT` をスペース区切りで解析:

| 引数 | 必須 | 説明 | デフォルト |
|------|------|------|-----------|
| 第1引数 | ✅ | 要件ソース | - |
| 第2引数 | - | 出力ファイルパス | 自動生成 |

### 要件ソースの判定

以下の優先順位で上から順に判定する（最初にマッチしたものを採用）:

1. `#` で始まる、または数字のみ → GitHub Issue 番号（`#42` や `42` → Issue #42）
2. ファイルパスとして存在する → そのファイルを読み込む
3. それ以外 → 自然言語テキストとしてそのまま使用

### 出力パスの自動生成

第2引数が省略された場合:

- プロジェクト名を特定する（ralph-loop.md と同じ方式）:
  1. `git rev-parse --show-toplevel` でリポジトリルートの絶対パスを取得
  2. 取得したパスの末尾のディレクトリ名をプロジェクト名とする（例: `/Users/foo/my-project` → `my-project`）
  3. Git リポジトリ外の場合はカレントディレクトリ名を使用
- 出力先ディレクトリ: `~/tmp/claude-dev/{プロジェクト名}/`
- ファイル名:
  - Issue の場合: `issue-{番号}.md`
  - それ以外: `{要件の要約をケバブケースにしたもの}.md`
- ディレクトリが存在しない場合は `mkdir -p` で作成する

## 実行フロー

### Step 1: 要件の取得

要件ソースの種別に応じて情報を取得する。

#### GitHub Issue の場合

1. `gh issue view {番号} --comments` で Issue の詳細を取得する（タイトル、本文、ラベル、コメント）
2. Issue が存在しない、またはアクセスできない場合はエラー終了
3. Issue の内容から以下を抽出する:
   - **種別**: バグ修正 / 機能追加 / リファクタリング / ドキュメント（ラベルも参考にする）
   - **ゴール**: Issue が求めていること
   - **再現手順**: バグの場合、再現手順があれば把握
   - **受け入れ基準**: Issue 本文やコメントに記述があれば抽出
   - **関連情報**: コメントで追加された仕様・制約・議論の結論

**重要**: Issue の全コメントを読むこと。本文だけでなく、コメントで追加・変更された仕様も反映する。

#### ファイルパスの場合

ファイルを読み込み、要件テキストとして使用する。

#### 自然言語テキストの場合

そのまま要件テキストとして使用する。

### Step 2: プロジェクト理解

コードベースを探索し、以下を把握する:

1. **プロジェクト構造**: ディレクトリ構成、主要なファイル
2. **技術スタック**: 言語、フレームワーク、ライブラリ
3. **既存のパターン**: コーディング規約、アーキテクチャパターン（MVC、Clean Architecture など）
4. **テスト**: テストフレームワーク、テストファイルの配置規則
5. **設定ファイル**: `CLAUDE.md`、`README.md`、`package.json` 等から追加コンテキストを取得

### Step 3: 要件分析

要件テキストから以下を抽出する:

- **ゴール**: 最終的に何を達成したいか
- **スコープ**: 変更が及ぶ範囲
- **制約**: 技術的制約、互換性要件
- **受け入れ基準**: 完了の定義（記述があれば）

### Step 4: 不明点があればユーザーに確認

タスク分解を始める前に明確にしておくべき不明点があれば AskUserQuestion を利用しユーザーに確認する

### Step 5: タスク分解

以下のガイドラインに従ってタスクを分解する:

#### 粒度の基準

- **1タスク ≒ 1コミット**: 各タスクは独立してコミットできる単位
- **1タスクの実装時間目安**: Claude が 1 イテレーションで完了できる程度
- 大きすぎるタスクは分割する（目安: 3ファイル以上の変更が必要なら分割を検討）

#### 依存順序

- 基盤となるタスク（設定、モデル、ユーティリティ）を先に配置
- 依存されるコードが先、依存するコードが後

#### 種別に応じた分解パターン

- **バグ修正**: 原因調査 → 修正 → 回帰テスト追加
- **機能追加**: 基盤 → 実装 → テスト → 統合

#### タスクの記述

- 何を実装するかを具体的に記述（「認証機能を追加」ではなく「JWT トークン検証 middleware を src/middleware/auth.ts に実装」）
- タスクの実行に必要な情報は全て記載されている状態とする
- 既存コードへの変更は、対象ファイルパスを明記
- 新規ファイルの場合は、配置先ディレクトリを明記

### Step 6: タスクリスト生成

以下の形式でファイルを出力する:

#### Issue の場合

```markdown
# Issue #{番号}: {Issue タイトル}

> Issue: #{番号}
> ラベル: {ラベル一覧}
> 生成日: {YYYY-MM-DD}

## 概要

{Issue の要約}

## タスク

- [ ] {タスク1の具体的な説明}
- [ ] {タスク2の具体的な説明}
...
```

**注意**: タスクリストのヘッダーに Issue 番号を記載することで、ralph-loop がコミット時に Issue 番号を参照できるようにする。

#### ファイル/テキストの場合

```markdown
# {要件タイトル}

> 生成元: {要件ソース}
> 生成日: {YYYY-MM-DD}

## 概要

{要件の簡潔なサマリー}

## 前提条件

- {プロジェクトの前提条件}

## タスク

- [ ] {タスク1の具体的な説明}
- [ ] {タスク2の具体的な説明}
- [ ] {タスク3の具体的な説明}
...
```

### Step 7: ユーザーへの報告

以下を表示する:

- 生成したタスクリストファイルのパス
- タスク総数
- ralph-loop での実行コマンド例: `/ralph-loop {出力ファイルパス}`
- 「タスクリストを確認し、必要に応じて手動で調整してください」という案内

## ルール

- **プロジェクトを読んでから分解する**: コードベースを理解せずにタスクを生成しない
- **既存パターンに沿う**: プロジェクトの既存のディレクトリ構造・命名規則・コーディングスタイルに合わせたタスクにする
- **実行可能なタスクのみ**: 曖昧な指示（「適切に実装する」）は避け、具体的なアクションを記述する
- **過剰な分解を避ける**: 些末なタスク（import 文の追加だけ等）は独立させず、関連タスクに含める
