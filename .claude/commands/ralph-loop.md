---
allowed-tools: Bash(basename:*), Bash(git status:*), Bash(git diff:*), Bash(git add:*), Bash(git commit:*), Bash(git log:*), Bash(git checkout -b:*), Bash(git rev-parse:*), Bash(mkdir:*), Edit(~/tmp/ralph-loop/**), Read(~/tmp/ralph-loop/**), Write(~/tmp/ralph-loop/**)
description: タスクリストファイルを元に Ralph Loop（自動実装ループ）を実行する
---

# Ralph Loop コマンド

タスクリストファイルを読み込み、未完了タスクを1つずつ自動で **実装 → テスト → コミット → 進捗記録** するループを実行します。

> **コンテキスト枯渇への対策**: このコマンドは単一セッション内でループするため、タスク数が多い場合はコンテキストが不足する可能性があります。各イテレーション完了時にコンテキストを圧縮して対策します（Step 8 参照）。タスク数が非常に多い場合（10以上）は、別ターミナルから `~/.claude/scripts/ralph-loop.sh` を直接実行することを検討してください。

## 引数の解析

`$ARGUMENT` をスペース区切りで解析:

| 引数 | 必須 | 説明 | デフォルト |
|------|------|------|-----------|
| 第1引数 | ✅ | タスクリストファイルのパス | - |
| 第2引数 | - | 最大イテレーション数 | 10 |

## 対応するタスクリスト形式

### Markdown チェックリスト（推奨）

```markdown
- [ ] ユーザー認証機能を追加
- [ ] APIエンドポイントを実装
- [x] 初期セットアップ（完了済み）
```

### JSON 形式（prd.json 互換）

```json
{
  "userStories": [
    { "id": "US-001", "title": "タスク名", "priority": 1, "passes": false }
  ]
}
```

### その他の形式

番号付きリスト、見出し付きセクションなど、タスクとして認識できる形式であれば柔軟に対応してください。完了/未完了の判定が難しい場合は、ファイル先頭にチェックリスト形式のサマリーセクションを追加してください。

## 実行フロー

### Phase 0: 初期化

1. タスクリストファイルを読み込む（存在しない場合はエラー終了）
2. ワーキングディレクトリの確認:
   - `git status` で未コミットの変更がないか確認する
   - 未コミット変更がある場合はユーザーに警告し、続行するか確認を取る（無関係な変更が混入するリスクがあるため）
3. 進捗ログの準備:
   - プロジェクト名を特定する（Git リポジトリ外の場合はカレントディレクトリ名）:
     1. `git rev-parse --show-toplevel` でリポジトリルートの絶対パスを取得
     2. 取得したパスを引数にして `basename <パス>` でディレクトリ名を取得
   - 進捗ログファイルのパス: `~/tmp/ralph-loop/{プロジェクト名}/{タスクファイル名の拡張子なし}.progress.md`
   - ディレクトリがなければ `mkdir -p` で作成
   - 既存の進捗ログがあれば読み込み、過去の学びを把握する
4. プロジェクトのテストコマンドを検出する（以下の優先順位で確認）:
   - `README.md` や `CLAUDE.md` にテスト実行方法の記載がないか確認
   - 設定ファイルから検出:
     - `package.json` の `scripts.test` → `npm test` / `pnpm test`
     - `Makefile` の `test` ターゲット → `make test`
     - `Cargo.toml` → `cargo test`
     - `pyproject.toml` / `setup.py` → `pytest`
     - `go.mod` → `go test ./...`
   - いずれにも見つからない場合 → テスト実行をスキップ
5. 未完了タスクの総数を確認し、全て完了済みなら即座に終了

### Phase 1: ループ実行

各イテレーションで以下を実行（イテレーション開始時にヘッダーを表示）:

```
═══ イテレーション N/MAX ═══
```

#### Step 1: 状態の再読み込み
- タスクリストファイルを再読み込みし、最新の完了状態を把握する
- 進捗ログファイルを再読み込みし、過去の学びを復元する（compact によるコンテキスト圧縮への対策）

#### Step 2: タスク選択
- 未完了タスクから1つ選択（priority がある場合は優先度順、なければファイル内順序）
- 選択したタスクをユーザーに表示

#### Step 3: 実装
- タスクの要件を分析し、必要なコードを実装
- 1タスクの範囲を超えないこと

#### Step 4: テスト実行
- Phase 0 で検出したテストコマンドを実行
- テスト失敗時: 修正を試み、3回失敗したらスキップ（理由を進捗ログに記録）

#### Step 5: 完了マーク
- タスクリストファイルを更新して、完了したタスクにマークを付ける
- 形式に応じた更新方法:
  - Markdown チェックリスト: `- [ ]` → `- [x]`
  - JSON: `"passes": false` → `"passes": true`
  - その他の形式: ファイル内の既存の完了マーク表記を確認し、同じ方式に従う（例: `[DONE]`、`✅`、~~取り消し線~~ など）

#### Step 6: コミット
- `~/.claude/commands/smart-commit.md` の手順を読み込み、その内容に従って変更を分析し論理的なコミットに分割・実行する

#### Step 7: 進捗ログ追記
- 進捗ログファイル（Phase 0 で特定したパス）に Edit ツールで追記する（Bash の `cat >>` やヒアドキュメントは使わない）
- 追記する形式:

```markdown
## [YYYY-MM-DD] - イテレーション N
### タスク: [タスク名/ID]
- **実装内容**: [概要]
- **変更ファイル**: [一覧]
- **学んだこと**: [パターンや注意点]
---
```

#### Step 8: コンテキスト圧縮と継続判定
- 全タスク完了 → Phase 2 へ
- 最大イテレーション到達 → Phase 2 へ
- 未完了タスク残存 → **`/compact` を実行してコンテキストを圧縮してから**次のイテレーションへ進む（Step 1 で進捗ログから状態を復元するため、圧縮しても情報は失われない）

### Phase 2: 終了

**全タスク完了の場合:**
- 完了サマリーを表示（完了タスク数、コミット一覧）

**最大イテレーション到達の場合:**
- 完了したタスクのサマリーを表示
- 残りの未完了タスク一覧を表示

## ルール

- **1イテレーション = 1タスク**: 確実に1つずつ完了させる
- **コンテキスト活用**: 進捗ログの「学んだこと」を後続タスクに活かす
- **最小限の変更**: タスクの要件に必要な変更のみ行う
- **スキップ判断**: 明らかに現在のプロジェクト状態では不可能なタスクは、理由を記録してスキップし次へ進む
